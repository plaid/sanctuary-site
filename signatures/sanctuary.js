window['signatures/sanctuary'] = [
  'create :: { checkTypes :: Boolean, env :: Array Type } -> Module',
  'env :: Array Type',
  '__ :: Placeholder',
  'type :: Any -> String',
  'is :: TypeRep a -> Any -> Boolean',
  'toString :: Any -> String',
  'equals :: Setoid a => a -> a -> Boolean',
  'concat :: Semigroup a => a -> a -> a',
  'empty :: Monoid a => TypeRep a -> a',
  'map :: Functor f => (a -> b) -> f a -> f b',
  'bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d',
  'promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d',
  'alt :: Alt f => f a -> f a -> f a',
  'zero :: Plus f => TypeRep f -> f a',
  'reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b',
  'reduce_ :: Foldable f => ((b, a) -> b) -> b -> f a -> b',
  'traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)',
  'sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)',
  'ap :: Apply f => f (a -> b) -> f a -> f b',
  'lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c',
  'lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d',
  'apFirst :: Apply f => f a -> f b -> f a',
  'apSecond :: Apply f => f a -> f b -> f b',
  'of :: Applicative f => TypeRep f -> a -> f a',
  'chain :: Chain m => (a -> m b) -> m a -> m b',
  'join :: Chain m => m (m a) -> m a',
  'chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b',
  'extend :: Extend w => (w a -> b) -> w a -> w b',
  'extract :: Comonad w => w a -> a',
  'filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean) -> f a -> f a',
  'filterM :: (Monad m, Monoid (m a)) => (a -> Boolean) -> m a -> m a',
  'I :: a -> a',
  'K :: a -> b -> a',
  'A :: (a -> b) -> a -> b',
  'T :: a -> (a -> b) -> b',
  'curry2 :: ((a, b) -> c) -> a -> b -> c',
  'curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d',
  'curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e',
  'curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f',
  'flip :: (a -> b -> c) -> b -> a -> c',
  'flip_ :: ((a, b) -> c) -> b -> a -> c',
  'compose :: (b -> c) -> (a -> b) -> a -> c',
  'pipe :: [(a -> b), (b -> c), ..., (m -> n)] -> a -> n',
  'on :: (b -> b -> c) -> (a -> b) -> a -> a -> c',
  'on_ :: ((b, b) -> c) -> (a -> b) -> a -> a -> c',
  'MaybeType :: Type -> Type',
  'Maybe :: TypeRep Maybe',
  'Nothing :: Maybe a',
  'Just :: a -> Maybe a',
  'Maybe.@@type :: String',
  'Maybe.fantasy-land/empty :: () -> Maybe a',
  'Maybe.fantasy-land/of :: a -> Maybe a',
  'Maybe.fantasy-land/zero :: () -> Maybe a',
  'Maybe#isNothing :: Maybe a ~> Boolean',
  'Maybe#isJust :: Maybe a ~> Boolean',
  'Maybe#toString :: Maybe a ~> () -> String',
  'Maybe#inspect :: Maybe a ~> () -> String',
  'Maybe#fantasy-land/equals :: Maybe a ~> Maybe a -> Boolean',
  'Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a',
  'Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b',
  'Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b',
  'Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b',
  'Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a',
  'Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b',
  'Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)',
  'Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b',
  'isNothing :: Maybe a -> Boolean',
  'isJust :: Maybe a -> Boolean',
  'fromMaybe :: a -> Maybe a -> a',
  'fromMaybe_ :: (() -> a) -> Maybe a -> a',
  'maybeToNullable :: Maybe a -> Nullable a',
  'toMaybe :: a? -> Maybe a',
  'maybe :: b -> (a -> b) -> Maybe a -> b',
  'maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b',
  'justs :: Array (Maybe a) -> Array a',
  'mapMaybe :: (a -> Maybe b) -> Array a -> Array b',
  'encase :: (a -> b) -> a -> Maybe b',
  'encase2 :: (a -> b -> c) -> a -> b -> Maybe c',
  'encase2_ :: ((a, b) -> c) -> a -> b -> Maybe c',
  'encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d',
  'encase3_ :: ((a, b, c) -> d) -> a -> b -> c -> Maybe d',
  'maybeToEither :: a -> Maybe b -> Either a b',
  'EitherType :: Type -> Type -> Type',
  'Either :: TypeRep Either',
  'Left :: a -> Either a b',
  'Right :: b -> Either a b',
  'Either.@@type :: String',
  'Either.fantasy-land/of :: b -> Either a b',
  'Either#isLeft :: Either a b ~> Boolean',
  'Either#isRight :: Either a b ~> Boolean',
  'Either#toString :: Either a b ~> () -> String',
  'Either#inspect :: Either a b ~> () -> String',
  'Either#fantasy-land/equals :: Either a b ~> Either a b -> Boolean',
  'Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b',
  'Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c',
  'Either#fantasy-land/bimap :: Either a b ~> (a -> c, b -> d) -> Either c d',
  'Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c',
  'Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c',
  'Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b',
  'Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c',
  'Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)',
  'Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c',
  'isLeft :: Either a b -> Boolean',
  'isRight :: Either a b -> Boolean',
  'fromEither :: b -> Either a b -> b',
  'toEither :: a -> b? -> Either a b',
  'either :: (a -> c) -> (b -> c) -> Either a b -> c',
  'lefts :: Array (Either a b) -> Array a',
  'rights :: Array (Either a b) -> Array b',
  'encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r',
  'encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r',
  'encaseEither2_ :: (Error -> l) -> ((a, b) -> r) -> a -> b -> Either l r',
  'encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r',
  'encaseEither3_ :: (Error -> l) -> ((a, b, c) -> r) -> a -> b -> c -> Either l r',
  'eitherToMaybe :: Either a b -> Maybe b',
  'and :: Boolean -> Boolean -> Boolean',
  'or :: Boolean -> Boolean -> Boolean',
  'not :: Boolean -> Boolean',
  'ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b',
  'allPass :: Array (a -> Boolean) -> a -> Boolean',
  'anyPass :: Array (a -> Boolean) -> a -> Boolean',
  'concat :: Semigroup a => a -> a -> a',
  'slice :: Integer -> Integer -> List a -> Maybe (List a)',
  'at :: Integer -> List a -> Maybe a',
  'head :: List a -> Maybe a',
  'last :: List a -> Maybe a',
  'tail :: List a -> Maybe (List a)',
  'init :: List a -> Maybe (List a)',
  'take :: Integer -> List a -> Maybe (List a)',
  'takeLast :: Integer -> List a -> Maybe (List a)',
  'drop :: Integer -> List a -> Maybe (List a)',
  'dropLast :: Integer -> List a -> Maybe (List a)',
  'reverse :: List a -> List a',
  'indexOf :: a -> List a -> Maybe Integer',
  'lastIndexOf :: a -> List a -> Maybe Integer',
  'append :: a -> Array a -> Array a',
  'prepend :: a -> Array a -> Array a',
  'joinWith :: String -> Array String -> String',
  'find :: (a -> Boolean) -> Array a -> Maybe a',
  'pluck :: Accessible a => String -> Array a -> Array b',
  'unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a',
  'range :: Integer -> Integer -> Array Integer',
  'prop :: Accessible a => String -> a -> b',
  'props :: Accessible a => Array String -> a -> b',
  'get :: Accessible a => (b -> Boolean) -> String -> a -> Maybe c',
  'gets :: Accessible a => (b -> Boolean) -> Array String -> a -> Maybe c',
  'keys :: StrMap a -> Array String',
  'values :: StrMap a -> Array a',
  'pairs :: StrMap a -> Array (Pair String a)',
  'negate :: ValidNumber -> ValidNumber',
  'add :: FiniteNumber -> FiniteNumber -> FiniteNumber',
  'sum :: Foldable f => f FiniteNumber -> FiniteNumber',
  'sub :: FiniteNumber -> FiniteNumber -> FiniteNumber',
  'inc :: FiniteNumber -> FiniteNumber',
  'dec :: FiniteNumber -> FiniteNumber',
  'mult :: FiniteNumber -> FiniteNumber -> FiniteNumber',
  'product :: Foldable f => f FiniteNumber -> FiniteNumber',
  'div :: FiniteNumber -> NonZeroFiniteNumber -> FiniteNumber',
  'mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber',
  'min :: Ord a => a -> a -> a',
  'max :: Ord a => a -> a -> a',
  'even :: Integer -> Boolean',
  'odd :: Integer -> Boolean',
  'parseDate :: String -> Maybe Date',
  'parseFloat :: String -> Maybe Number',
  'parseInt :: Integer -> String -> Maybe Integer',
  'parseJson :: (a -> Boolean) -> String -> Maybe b',
  'regex :: RegexFlags -> String -> RegExp',
  'regexEscape :: String -> String',
  'test :: RegExp -> String -> Boolean',
  'match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }',
  'matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }',
  'toUpper :: String -> String',
  'toLower :: String -> String',
  'trim :: String -> String',
  'words :: String -> Array String',
  'unwords :: Array String -> String',
  'lines :: String -> Array String',
  'unlines :: Array String -> String',
  'splitOn :: String -> String -> Array String',
];
